import type { StricliKitConfig } from "./config.js";
import type {
  GeneratedRouteMap,
  GeneratorOptions,
  ScannedRoute,
} from "./types.js";
import { existsSync, readFileSync } from "node:fs";
import { mkdir, writeFile } from "node:fs/promises";
import { dirname, join } from "node:path";
import { readConfig } from "./config.js";
import { pathToIdentifier, SPECIAL_FILES } from "./conventions.js";
import {
  hasRootConfig,
  hasRouteConfig,
  scanCommandsDirectory,
} from "./scanner.js";

// ============================================================================
// Types
// ============================================================================

interface PackageJson {
  name?: string;
  version?: string;
}

interface RouteImport {
  identifier: string;
  path: string;
  isConfig: boolean;
}

interface GeneratedFile {
  path: string;
  content: string;
}

// ============================================================================
// Pure utility functions (easily testable)
// ============================================================================

/**
 * Read package.json from a directory
 */
export function readPackageJson(dir: string): PackageJson {
  const packageJsonPath = join(dir, "package.json");
  if (!existsSync(packageJsonPath)) {
    return {};
  }
  const content = readFileSync(packageJsonPath, "utf-8");
  return JSON.parse(content) as PackageJson;
}

/**
 * Check if a property name needs to be quoted in JavaScript object literals
 */
export function needsQuotes(name: string): boolean {
  return !/^[a-zA-Z_$][a-zA-Z0-9_$]*$/.test(name);
}

/**
 * Quote a property name if needed for JavaScript object literals
 */
export function quotePropertyName(name: string): string {
  return needsQuotes(name) ? `"${name}"` : name;
}

/**
 * Convert a relative path to its import path (replace .ts with .js)
 */
export function toImportPath(
  relativePath: string,
  importPrefix: string,
): string {
  const normalizedPath = relativePath
    .replace(/\.lazy\.ts$/, ".lazy.js")
    .replace(/\.ts$/, ".js");
  return `${importPrefix}/${normalizedPath}`;
}

/**
 * Build a config import path from a relative path
 */
export function toConfigImportPath(
  relativePath: string,
  importPrefix: string,
): string {
  const configFile = SPECIAL_FILES.ROUTE_CONFIG.replace(".ts", ".js");
  return `${importPrefix}/${relativePath}/${configFile}`;
}

// ============================================================================
// Import generation (pure functions)
// ============================================================================

/**
 * Collect all imports from a route tree (pure function)
 */
export function collectRouteImports(
  routes: ScannedRoute[],
  importPrefix: string,
  checkHasRouteConfig: (filePath: string) => boolean = hasRouteConfig,
): RouteImport[] {
  const imports: RouteImport[] = [];

  function processRoute(route: ScannedRoute): void {
    if (route.isDirectory) {
      if (checkHasRouteConfig(route.filePath)) {
        imports.push({
          identifier: `${pathToIdentifier(route.relativePath)}_config`,
          path: toConfigImportPath(route.relativePath, importPrefix),
          isConfig: true,
        });
      }
      for (const child of route.children ?? []) {
        processRoute(child);
      }
    } else {
      imports.push({
        identifier: `${pathToIdentifier(route.relativePath)}Route`,
        path: toImportPath(route.relativePath, importPrefix),
        isConfig: false,
      });
    }
  }

  for (const route of routes) {
    processRoute(route);
  }

  return imports;
}

/**
 * Format route imports as import statements
 */
export function formatImportStatements(imports: RouteImport[]): string[] {
  return imports.map((imp) => {
    if (imp.isConfig) {
      const baseName = imp.identifier.replace(/_config$/, "");
      return `import { config as ${baseName}_config } from "${imp.path}";`;
    }
    return `import { route as ${imp.identifier} } from "${imp.path}";`;
  });
}

// ============================================================================
// File content generation (pure functions)
// ============================================================================

const GENERATED_HEADER = [
  "// AUTO-GENERATED - DO NOT EDIT",
  "// Generated by @macalinao/stricli-codegen",
  "",
];

/**
 * Generate the create-file-route.ts helper file content
 */
export function generateCreateFileRouteContent(
  importPrefix: string,
  hasRoot: boolean,
  utilsPackage: string,
): string {
  const lines: string[] = [
    ...GENERATED_HEADER,
    `import type { Route, RouteMeta } from "${utilsPackage}";`,
    'import type { Command } from "@stricli/core";',
  ];

  const rootConfigPath = `${importPrefix}/${SPECIAL_FILES.ROOT_CONFIG.replace(".ts", ".js")}`;

  if (hasRoot) {
    lines.push(
      `import type { AppContext } from "${rootConfigPath}";`,
      "",
      "/**",
      " * Create a typed route for this application.",
      " * Context type is inferred from __root.ts.",
      " */",
      "export function createFileRoute(route: {",
      "  meta?: RouteMeta;",
      "  command: Command<AppContext>;",
      "}): Route<AppContext> {",
      "  return route;",
      "}",
      "",
      "// Re-export for type access when needed",
      "export type { AppContext };",
    );
  } else {
    lines.push(
      'import type { CommandContext } from "@stricli/core";',
      "",
      "/**",
      " * Create a typed route for this application.",
      " */",
      "export function createFileRoute(route: {",
      "  meta?: RouteMeta;",
      "  command: Command<CommandContext>;",
      "}): Route<CommandContext> {",
      "  return route;",
      "}",
    );
  }

  lines.push("");
  return lines.join("\n");
}

// ============================================================================
// Route map code generation (pure functions)
// ============================================================================

interface RouteMapGeneratorContext {
  indent: string;
  checkHasRouteConfig: (filePath: string) => boolean;
}

/**
 * Generate a single directory route entry
 */
function generateDirectoryRouteEntry(
  route: ScannedRoute,
  ctx: RouteMapGeneratorContext,
): string {
  const { indent, checkHasRouteConfig } = ctx;
  const childIndent = `${indent}  `;
  const nestedIndent = `${indent}    `;

  const childCode = generateRouteMapCodePure(route.children ?? [], {
    indent: nestedIndent,
    checkHasRouteConfig,
  });

  const identifier = pathToIdentifier(route.relativePath);
  const hasConfig = checkHasRouteConfig(route.filePath);

  const configSpread = hasConfig
    ? `\n${nestedIndent}...${identifier}_config,`
    : "";
  const routeMapOptions = `{\n${nestedIndent}routes: ${childCode},${configSpread}\n${childIndent}}`;

  return `${childIndent}${quotePropertyName(route.name)}: buildRouteMap(${routeMapOptions})`;
}

/**
 * Generate a single file route entry
 */
function generateFileRouteEntry(route: ScannedRoute, indent: string): string {
  const childIndent = `${indent}  `;
  const identifier = pathToIdentifier(route.relativePath);
  const routeName = route.name || "index";

  return `${childIndent}${quotePropertyName(routeName)}: ${identifier}Route.command`;
}

/**
 * Generate the route map code for a set of routes (pure function)
 */
export function generateRouteMapCodePure(
  routes: ScannedRoute[],
  ctx: RouteMapGeneratorContext,
): string {
  const routeEntries = routes.map((route) => {
    if (route.isDirectory) {
      return generateDirectoryRouteEntry(route, ctx);
    }
    return generateFileRouteEntry(route, ctx.indent);
  });

  return `{\n${routeEntries.join(",\n")},\n${ctx.indent}}`;
}

/**
 * Generate the route map code (convenience wrapper with defaults)
 */
function generateRouteMapCode(routes: ScannedRoute[], indent = "  "): string {
  return generateRouteMapCodePure(routes, {
    indent,
    checkHasRouteConfig: hasRouteConfig,
  });
}

/**
 * Generate the app.ts file content
 */
export function generateAppFileContent(
  importPrefix: string,
  packageJson: PackageJson,
  utilsPackage: string,
): string {
  const rootConfigPath = `${importPrefix}/${SPECIAL_FILES.ROOT_CONFIG.replace(".ts", ".js")}`;
  const name = packageJson.name ?? "cli";
  const version = packageJson.version ?? "0.0.0";

  const lines: string[] = [
    ...GENERATED_HEADER,
    'import type { Application } from "@stricli/core";',
    `import type { AppContext } from "${rootConfigPath}";`,
    "",
    `import { createAppContextAsync } from "${utilsPackage}";`,
    'import { buildApplication } from "@stricli/core";',
    "",
    `import { root } from "${rootConfigPath}";`,
    'import { routes } from "./route-map.js";',
    "",
    "export const app: Application<AppContext> = buildApplication(routes, {",
    `  name: root.appConfig.name ?? "${name}",`,
    "  versionInfo: {",
    `    currentVersion: root.appConfig.version ?? "${version}",`,
    "  },",
    "});",
    "",
    "export const createContext = () => createAppContextAsync<AppContext>(root.appConfig.context);",
    "",
  ];

  return lines.join("\n");
}

/**
 * Generate the route map file header imports
 */
function generateRouteMapHeader(
  importPrefix: string,
  hasRoot: boolean,
): string[] {
  const rootConfigPath = `${importPrefix}/${SPECIAL_FILES.ROOT_CONFIG.replace(".ts", ".js")}`;
  const lines: string[] = [...GENERATED_HEADER];

  if (hasRoot) {
    lines.push(
      'import type { RouteMap } from "@stricli/core";',
      `import type { AppContext } from "${rootConfigPath}";`,
      "",
      'import { buildRouteMap } from "@stricli/core";',
      `import { root } from "${rootConfigPath}";`,
    );
  } else {
    lines.push(
      'import type { CommandContext, RouteMap } from "@stricli/core";',
      "",
      'import { buildRouteMap } from "@stricli/core";',
    );
  }

  return lines;
}

/**
 * Generate the route map export section
 */
function generateRouteMapExport(
  routes: ScannedRoute[],
  hasRoot: boolean,
): string[] {
  const contextType = hasRoot ? "AppContext" : "CommandContext";
  const routeMapCode = generateRouteMapCode(routes);

  const lines = [
    `export const routes: RouteMap<${contextType}> = buildRouteMap({`,
    `  routes: ${routeMapCode},`,
  ];

  if (hasRoot) {
    lines.push("  ...root.routeConfig,");
  }

  lines.push("});", "");
  return lines;
}

/**
 * Generate the complete route map TypeScript file content
 */
export function generateRouteMapFileContent(
  routes: ScannedRoute[],
  importPrefix: string,
  hasRoot: boolean,
): string {
  const routeImports = collectRouteImports(routes, importPrefix);
  const importStatements = formatImportStatements(routeImports);

  const lines: string[] = [
    ...generateRouteMapHeader(importPrefix, hasRoot),
    "",
    ...importStatements,
    "",
    ...generateRouteMapExport(routes, hasRoot),
  ];

  return lines.join("\n");
}

// ============================================================================
// Route tree utilities
// ============================================================================

/**
 * Collect all file paths from a route tree (pure function)
 */
export function collectRouteFilePaths(routes: ScannedRoute[]): string[] {
  const paths: string[] = [];

  function collect(routeList: ScannedRoute[]): void {
    for (const route of routeList) {
      if (route.isDirectory) {
        collect(route.children ?? []);
      } else {
        paths.push(route.filePath);
      }
    }
  }

  collect(routes);
  return paths;
}

// ============================================================================
// File generation orchestration
// ============================================================================

/**
 * Build all generated files (pure function - no I/O)
 */
export function buildGeneratedFiles(
  routes: ScannedRoute[],
  importPrefix: string,
  hasRoot: boolean,
  packageJson: PackageJson,
  outputDir: string,
  outputPath: string,
  config: StricliKitConfig,
): GeneratedFile[] {
  const files: GeneratedFile[] = [];
  const utilsPackage = config.utilsPackage ?? "@macalinao/stricli-kit";

  const routeMapCode = generateRouteMapFileContent(
    routes,
    importPrefix,
    hasRoot,
  );
  files.push({ path: outputPath, content: routeMapCode });

  const createFileRouteCode = generateCreateFileRouteContent(
    importPrefix,
    hasRoot,
    utilsPackage,
  );
  files.push({
    path: join(outputDir, "create-file-route.ts"),
    content: createFileRouteCode,
  });

  if (hasRoot) {
    const appCode = generateAppFileContent(
      importPrefix,
      packageJson,
      utilsPackage,
    );
    files.push({ path: join(outputDir, "app.ts"), content: appCode });
  }

  return files;
}

/**
 * Write generated files to disk
 */
async function writeGeneratedFiles(files: GeneratedFile[]): Promise<void> {
  for (const file of files) {
    await writeFile(file.path, file.content, "utf-8");
  }
}

/**
 * Generate the route map from a commands directory
 */
export async function generateRouteMap(
  options: GeneratorOptions,
): Promise<GeneratedRouteMap> {
  const { commandsDir, outputPath, importPrefix = "../commands" } = options;

  const routes = scanCommandsDirectory(commandsDir);
  const hasRoot = hasRootConfig(commandsDir);

  const outputDir = dirname(outputPath);
  if (!existsSync(outputDir)) {
    await mkdir(outputDir, { recursive: true });
  }

  const packageRoot = dirname(dirname(outputDir));
  const packageJson = readPackageJson(packageRoot);
  const config = readConfig(packageRoot);

  const files = buildGeneratedFiles(
    routes,
    importPrefix,
    hasRoot,
    packageJson,
    outputDir,
    outputPath,
    config,
  );

  await writeGeneratedFiles(files);

  const code = files[0]?.content ?? "";

  return {
    code,
    imports: collectRouteFilePaths(routes),
    routeTree: routes,
  };
}
